//-----------------------------------------------
// Copyright 2016 National Chung Cheng University
// Written by Yao-Ting Huang & Ping-Yeh Chen
// Released under the GPL
//-----------------------------------------------
//
// PacBioHybridCorrectionProcess - Hybrid correction using FM-index walk for PacBio reads
//

#include "PacBioHybridCorrectionProcess.h"
#include "CorrectionThresholds.h"
#include "HashMap.h"
#include <iomanip>
#include "SAIPBHybridCTree.h"
#include "SAIPBSelfCTree.h"
#include "Timer.h"
#include "multiple_alignment.h"
#include "LongReadOverlap.h"

using namespace std;


PacBioHybridCorrectionProcess::PacBioHybridCorrectionProcess(const PacBioHybridCorrectionParameters params):m_params(params)
{
}

PacBioHybridCorrectionProcess::~PacBioHybridCorrectionProcess()
{
}

// PacBio Hybrid Correction by Ya, v20160216.
PacBioHybridCorrectionResult PacBioHybridCorrectionProcess::PBHybridCorrection(const SequenceWorkItem& workItem)
{
	PacBioHybridCorrectionResult result;
	
	// std::cout << workItem.read.id <<"\n";
	std::vector<SeedFeature> seedVec, pacbioCorrectedStrs;
	std::string readSeq = workItem.read.seq.toString();
	//seedVec = seedingByDynamicKmer(readSeq);
	seedVec = seedingByDynamicKmer(readSeq);
	
	if(seedVec.size() >= 2)
	{
		result.correctedLen += seedVec.at(0).seedLength;
		pacbioCorrectedStrs.push_back(seedVec.at(0));
	}
	else
	{
		result.merge = false;
		return result;
	}
	
	// FMWalk for each pair of seeds
	for(size_t targetSeed = 1 ; targetSeed < seedVec.size() ; targetSeed++)
	{
		SeedFeature preTarget = seedVec.at(targetSeed-1);
		SeedFeature source = pacbioCorrectedStrs.back();
		SeedFeature target = seedVec.at(targetSeed);
		int dis_between_src_target = target.seedStartPos - preTarget.seedEndPos - 1;
		
		// we need raw pacbio string between source and target seed and 10 bp around
		// to do global alignmet with fmwalk result.
		string strBetweenSrcTarget = readSeq.substr(preTarget.seedEndPos+1-10, dis_between_src_target+20);
		
		int FMWalkReturnType;
		FMWalkResult FMWResult;
		FMWalkReturnType = extendBetweenSeeds(source, target, strBetweenSrcTarget, dis_between_src_target, &FMWResult, targetSeed);
		
		// record corrected pacbio reads string
		// FMWalk success
		if(FMWalkReturnType == 1)
		{
			size_t gainPos = source.seedLength;
			// have gain ground
			if(FMWResult.mergedSeq.length() > gainPos)
			{
				string gainStr = FMWResult.mergedSeq.substr(gainPos);
				pacbioCorrectedStrs.back().append(gainStr);
				pacbioCorrectedStrs.back().isRepeat = target.isRepeat;
				pacbioCorrectedStrs.back().isPBSeed = target.isPBSeed;
				pacbioCorrectedStrs.back().startBestKmerSize = target.startBestKmerSize;
				pacbioCorrectedStrs.back().endBestKmerSize = target.endBestKmerSize;

				result.correctedLen += gainStr.length();
			}
		}
		// FMWalk failure: 
		// 1. high error 
		// 2. exceed leaves
		// 3. exceed depth
		else
		{
			//std::cout << FMWalkReturnType << ":\t" << source.seedStr << "\t" << target.seedStr << "\t" << dis_between_src_target << "\n";	
			pacbioCorrectedStrs.push_back(target);
			result.correctedLen += target.seedLength;
		}
		
		// output information
		result.totalWalkNum++;			
		result.seedDis += dis_between_src_target;
		if(FMWalkReturnType == 1)
			result.correctedNum++;
	}
	
	// std::string query = readSeq.substr(seedVec.back().seedStartPos);
	// size_t sourceKmerLength = seedVec.back().startBestKmerSize;
	
	// std::cout << readSeq.substr(seedVec.back().seedStartPos, sourceKmerLength) << "\t" << query.length() << "\n" ;
	
	// Self correction by aligning all reads having seeds with query
	// MultipleAlignment maquery = LongReadOverlap::endMultipleAlignment(query,
												// sourceKmerLength,//m_params.PBKmerLength, 
												// query.length()/10, 
												// 0.7,	// alignment identity < 0.7 are often false positive repeats
												// m_params.PBcoverage,
												// m_params.PBindices); 

	// std::cout << query.length()<< "\t" << maquery.getNumRows() <<"\n";
	
	// maquery.print(120);
	// std::string consensus = maquery.calculateBaseConsensus(100000, 5);
	// std::cout << ">" << consensus.length() <<"\n" << consensus << "\n";
		
	result.totalSeedNum = seedVec.size();
	result.totalReadsLen = readSeq.length();
	result.merge = true;
	for(size_t result_count = 0 ; result_count < pacbioCorrectedStrs.size() ; result_count++)
		result.correctedPacbioStrs.push_back(pacbioCorrectedStrs[result_count].seedStr);
	
	return result;
}


// PacBio Hybrid Correction Seeding By Dynamic Kmer v2, v20160511 by Ya.
// find seeds by dynamic kmers, which is suitable for the PacBio hybrid error correction,
// where repeat regions require large kmers and error-prone regions require small kmers.
std::vector<SeedFeature> PacBioHybridCorrectionProcess::seedingByDynamicKmer_v2(const string& readSeq)
{
	std::vector<std::vector<size_t> > PBKmerFreqsVec;
	std::vector<SeedFeature> seedVec;
	std::vector<int> seedEndPosVec;
	int prevPBSeedEndPos = 0;
	
	size_t maxKmerSize = m_params.kmerLength;
	size_t minKmerSize = m_params.minKmerLength;
	size_t kmerThreshold = m_params.seedKmerThreshold;
	
	// prevention of short reads
	if(readSeq.length() < maxKmerSize)
		return seedVec;
	
	// computing maximum interval of variously consecutive matches length (dk figure)
	std::vector<int> maxSeedInterval;
	for(size_t i = 0 ; i <= maxKmerSize ; i++)
		maxSeedInterval.push_back(2*3.8649*pow(2.7183,0.1239*i));
	
	PBKmerFreqsVec.clear();
	PBKmerFreqsVec.resize(readSeq.length());
	int numValidPos = calculateKmerFreqsEachPBPos(readSeq, PBKmerFreqsVec);
	// only 24% of pacbio reads have more than two seeds
	// so we end the seeding function as early as possible
	if(numValidPos < 2)
		return seedVec;
	
	// set dynamic kmer as largest kmer initially, 
	// which will reduce size when no seeds can be found within a maximum interval.
	size_t dynamicKmerSize = maxKmerSize;
	//size_t dynamicKmerThreshold = kmerThreshold;

	// search for solid kmers and group consecutive solids kmers into one seed
	// reduce kmer size if no seeds can be found within maxSeedInterval
	for(size_t i = 0 ; i+dynamicKmerSize <= readSeq.length() ; i++)
	{
		size_t PBKmerSize = minKmerSize+PBKmerFreqsVec.at(i).size()-1;
		
		if(PBKmerSize == dynamicKmerSize)
		{
			size_t seedStartPos = i;
			size_t maxKmerFreq = PBKmerFreqsVec.at(i).back();
			std::cout << i << ":\t" << maxKmerFreq << "\t" << dynamicKmerSize << "\n";

			// group consecutive solid kmers into one seed if possible
			for(i++ ; i+dynamicKmerSize <= readSeq.length() ; i++)
			{
				PBKmerSize = minKmerSize+PBKmerFreqsVec.at(i).size()-1;
				if(PBKmerSize >= dynamicKmerSize)
				{
					maxKmerFreq = std::max(maxKmerFreq, PBKmerFreqsVec.at(i).back());
					std::cout << i << ":\t" << maxKmerFreq << "\t" << dynamicKmerSize << "\n";
				}
				else
					break;
			}
			
			size_t seedEndPos = i+dynamicKmerSize-2;

			// repeat seeds are less accurate at boundary and should be trimmed 
			if(maxKmerFreq > m_params.coverage*2)
				trimRepeatSeed(readSeq, m_params.coverage, dynamicKmerSize, seedStartPos, seedEndPos, m_params.indices);

			// small-sized seed has 50% chance of errors in C elegans, 
			// skip only if there is another seed nearby 30bp or dynamic kmerSize is too small
			if( (seedEndPos-seedStartPos+1 - dynamicKmerSize < 3) && !seedVec.empty() &&
				(seedEndPos-seedVec.back().seedEndPos <= 30 || dynamicKmerSize <= m_params.kmerLength-5) )
				continue;

			// super repeat seeds with frequency > 2000 are troublesome, often lead to -3 but no good solution so far, mark first
			// bool isSuperRepeat = maxKmerFreq > m_params.coverage*5?true:false;
			bool isSuperRepeat = maxKmerFreq >= m_params.coverage?true:false;
			// if(maxKmerFreq > m_params.coverage) continue;
			SeedFeature newSeed(seedStartPos, readSeq.substr(seedStartPos, seedEndPos-seedStartPos+1), isSuperRepeat, dynamicKmerSize,  m_params.coverage);
			// newSeed.estimateBestKmerSize(m_params.indices.pBWT);

			// super repeat are often in complex repeat regions where low-frequency seeds are errors.
			// if(!seedVec.empty() && (seedVec.back().isRepeat || newSeed.isRepeat))
			// {
				// if(!validateSeed(seedVec.back(), newSeed, maxKmerFreq))
				// {
					// // std::cout << "#" << seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";

					// seedEndPosVec.push_back(seedEndPos);
					// i = seedEndPos;
					// dynamicKmerSize = maxKmerSize;
					// // dynamicKmerThreshold = kmerThreshold;
					// continue;
				// }
			// }
			size_t PBkmerFreq = BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr.substr(0, dynamicKmerSize), m_params.PBindices);
			if( PBkmerFreq < 3 /*|| PBkmerFreq > m_params.PBcoverage*/) 
			{
				std::cout << "#" << seedStartPos << "." << PBkmerFreq << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";
				continue;
			}

			// skip low-complexity sequencing errors of PacBio
			// bool isShortAndHighFreq = i-seedStartPos <= 2 && maxKmerFreq > 80;
			if(!isLowComplexity(newSeed.seedStr, 0.9))
			{
				seedVec.push_back(newSeed);
			
				seedEndPosVec.push_back(seedEndPos);
				prevPBSeedEndPos = seedEndPos;
				
				// debug
				std::cout << ">" << seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize << "\n" << newSeed.seedStr << "\n";
				
				// jump to the index after new seed
				i = seedEndPos;
				dynamicKmerSize = maxKmerSize;
			}
		}
		
		// reduce kmer size if no seeds can be found within a maximum interval
		int prevSeedEndPos = seedEndPosVec.empty() ? 0 : seedEndPosVec.back()+1;
		int distToPrevSeed = i + 1 - prevSeedEndPos;
		if(distToPrevSeed >= (int)maxSeedInterval.at(dynamicKmerSize))
		{
			// reducing the kmer size
			if(dynamicKmerSize > minKmerSize)
			{
				i = prevSeedEndPos;
				dynamicKmerSize -= 2;
				//dynamicKmerThreshold +=2;
			}
			else
			{
				// collect seeds from PacBio reads if distToPrevSeed is too long due to sequencing gaps
				// int prevSeedVecPos = seedVec.empty() ? 0 : seedVec.back().seedEndPos+1;
				
				// // search of seeds in PB reads may also fail for over PBSearchDepth, restart according to prevSeedEndPos
				// if(prevSeedVecPos < prevSeedEndPos - m_params.PBSearchDepth)
					// prevSeedVecPos = prevSeedEndPos - m_params.PBSearchDepth;
				
				// distToPrevSeed = i + 1 - prevSeedVecPos;
				
				distToPrevSeed = i + 1 - prevPBSeedEndPos;
				
				// In large sequencing gaps (>7kb), no seeds can be found in Illumina index
				// If no seed is found within PBSearchDepth, 
				// seeds from PB index will be serached instead
				if(distToPrevSeed >= m_params.PBSearchDepth)
				{	
					if(seedingByPacBio(readSeq, seedVec, seedEndPosVec, prevPBSeedEndPos) 
						/*|| seedingByExtension(seedVec, seedEndPosVec)*/ )
						prevPBSeedEndPos = seedEndPosVec.back();
					else
						prevPBSeedEndPos = i;
				}
				
				// no seeds can be found even using minKmerSize, 
				// so we reset start position of searching to give up the maximum interval of minKmerSize.
				seedEndPosVec.push_back(i);
				dynamicKmerSize = maxKmerSize;
				//dynamicKmerThreshold = kmerThreshold;
			}
		}
	}
	
	return seedVec;
}

int PacBioHybridCorrectionProcess::calculateKmerFreqsEachPBPos(const std::string& readSeq, std::vector<std::vector<size_t> >& PBKmerFreqsVec)
{
	size_t maxKmerSize = m_params.kmerLength;
	size_t minKmerSize = m_params.minKmerLength;
	size_t kmerThreshold = m_params.seedKmerThreshold;
	assert(kmerThreshold - 2*(maxKmerSize-minKmerSize) > 0);
	
	int numValidPos = 0;
	for(size_t pos = 0 ; pos+maxKmerSize <= readSeq.length() ; pos++)
	{
		string kmer = readSeq.substr(pos, minKmerSize);
		BWTInterval fwdInterval = BWTAlgorithms::findInterval(m_params.indices.pRBWT, reverse(kmer));
		BWTInterval rvcInterval = BWTAlgorithms::findInterval(m_params.indices.pBWT, reverseComplement(kmer));
		size_t kmerFreqs = fwdInterval.size() + rvcInterval.size();
		size_t dynamicKmerThreshold = kmerThreshold;
		
		if(kmerFreqs < dynamicKmerThreshold)
			continue;
	
		PBKmerFreqsVec.at(pos).push_back(kmerFreqs);
		numValidPos++;
		for(size_t extendPos=pos+minKmerSize, count=1 ; count <= maxKmerSize-minKmerSize && extendPos < readSeq.length() ; extendPos++, count++)
		{
			char b = readSeq.at(extendPos);
			char rcb;
			switch(b)
			{
				case 'A': rcb='T'; break;
				case 'T': rcb='A'; break;
				case 'C': rcb='G'; break;
				case 'G': rcb='C'; break;
			}
			BWTAlgorithms::updateInterval(fwdInterval, b, m_params.indices.pRBWT);
			BWTAlgorithms::updateInterval(rvcInterval, rcb, m_params.indices.pBWT);
			kmerFreqs = fwdInterval.size() + rvcInterval.size();
			dynamicKmerThreshold -= 2;
			if(kmerFreqs >= dynamicKmerThreshold)
				PBKmerFreqsVec.at(pos).push_back(kmerFreqs);
			else
				break;
		}
	}
	
	return numValidPos;
}

bool PacBioHybridCorrectionProcess::seedingByPacBio(const string& readSeq, 	std::vector<SeedFeature>& seedVec, 	std::vector<int>& seedEndPosVec, int& prevEndPos)
{
	size_t dynamicKmerSize = m_params.kmerLength+10;
	size_t dynamicKmerThreshold = 6;
	
	// search for solid kmers and group consecutive solids kmers into one seed
	// reduce kmer size if no seeds can be found within maxSeedInterval
	for(int i = prevEndPos ; i+dynamicKmerSize < readSeq.length() ; i++)
	{
		string kmer = readSeq.substr(i, dynamicKmerSize);
		size_t fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices);
		size_t rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.PBindices);
		size_t kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
		
		// finding the seed
		if(kmerFreqs >= dynamicKmerThreshold && kmerFreqs < m_params.PBcoverage/2)
		{
			// std::cout << i << "::\t" << kmer << "\t" << kmerFreqs << "\t" << prevEndPos << "\t" << seedVec.back().isRepeat << "\n";

			size_t seedStartPos = i;
			size_t maxKmerFreq = kmerFreqs;
			
			// group consecutive solid kmers into one seed if possible
			for(i++ ; i+dynamicKmerSize <= readSeq.length() ; i++)
			{
				kmer = readSeq.substr(i, dynamicKmerSize);
				fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices);
				rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.PBindices);
				kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
				maxKmerFreq = std::max(maxKmerFreq,kmerFreqs);

				 // std::cout << i << "::\t" << kmer << "\t" << kmerFreqs << "\t" << seedStartPos << "\n";

				if(kmerFreqs < dynamicKmerThreshold || kmerFreqs >= m_params.PBcoverage/2)
					break;
			}
			
			// require sufficient seed length in repeats
			if(i-seedStartPos <= 2 /*&& dynamicKmerSize <= m_params.kmerLength*/){
				// std::cout << readSeq.substr(seedStartPos, i+dynamicKmerSize-2-seedStartPos+1) << "\n";
				continue;
			}

			size_t seedEndPos = i+dynamicKmerSize-2;

			// repeat seeds are less accurate at boundary and should be trimmed 
			// if(maxKmerFreq > m_params.PBcoverage/3)
				// trimRepeatSeed(readSeq, m_params.PBcoverage/3, dynamicKmerSize, seedStartPos, seedEndPos, m_params.PBindices);

			// super repeat seeds with frequency > 2000 are troublesome, often lead to -3 but no good solution so far, mark first
			bool isRepeat = maxKmerFreq >= m_params.PBcoverage/2?true:false;
			if(isRepeat) 
			{
				// if(maxKmerFreq >= m_params.PBcoverage*4)
					// i=seedEndPos+1;
				
				continue;
			}
			
			SeedFeature newSeed(seedStartPos, readSeq.substr(seedStartPos, seedEndPos-seedStartPos+1), isRepeat, dynamicKmerSize, m_params.PBcoverage/2);
			newSeed.estimateBestKmerSize(m_params.PBindices.pBWT);
			
			// super repeat are often in complex repeat regions where low-frequency seeds are errors.
			size_t indiceskmerFreq = BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr, m_params.indices);
			if(!seedVec.empty())
			{
				if( indiceskmerFreq < 6 || indiceskmerFreq > m_params.coverage*2/3
				    || !validateSeed(seedVec.back(), newSeed, maxKmerFreq) )
				{
					// std::cout << "#" << seedStartPos << "." << indiceskmerFreq << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";
					continue;
				}
			 }

			// skip low-complexity sequencing errors of PacBio
			// bool isShortAndHighFreq = i-seedStartPos <= 2 && maxKmerFreq > 80;
			if(!isLowComplexity(newSeed.seedStr, 0.9))
			{
				// debug
				 std::cout << ">>" << newSeed.seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";

				newSeed.isPBSeed = true;
				seedVec.push_back(newSeed);
				seedEndPosVec.push_back(seedEndPos);
				prevEndPos = seedEndPos;
			}
			return true;
		}

		// reduce kmer size if no seeds can be found within a maximum interval
		// int prevSeedEndPos = seedVec.empty() ? 0 : seedVec.back().seedEndPos+1;		
		int distToPrevSeed = i + 1 - prevEndPos;
		if(distToPrevSeed >= m_params.PBSearchDepth)
		{
			// return false;
			if(dynamicKmerSize > 21)
			{
				i = prevEndPos+1;
				dynamicKmerSize -= 2;
				// dynamicKmerThreshold += 1;
			}
			else
			{
				prevEndPos = i;
				return false;
			}
		}
	}
	
	// prevEndPos = i;
	return false;
}

bool PacBioHybridCorrectionProcess::seedingByExtension(std::vector<SeedFeature>& seedVec, std::vector<int>& seedEndPosVec)
{
	std::string initKmer = seedVec.back().seedStr;

	BWTInterval fwdInterval=BWTAlgorithms::findInterval(m_params.PBindices.pRBWT, reverse(initKmer));
	BWTInterval rvcInterval=BWTAlgorithms::findInterval(m_params.PBindices.pBWT, reverseComplement(initKmer));
    	
	size_t kmerFreq = 0;
	kmerFreq += fwdInterval.isValid()?fwdInterval.size():0;
	kmerFreq += fwdInterval.isValid()?rvcInterval.size():0;

	// std::cout << initKmer << "\t" << m_params.PBKmerLength << "\t" << reverseComplement(initKmer) << "\t" << fwdInterval.size() << "\t" << rvcInterval.size() << "\t" << kmerFreq << "\n";
	
	size_t count = 0;
	size_t dynamicKmerSize = 21;
	size_t dynamicKmerThreshold = 6;

	// extend each SA index and collect kmers of smallKmerSize along the extension
	for(int64_t fwdRootIndex = fwdInterval.lower; fwdInterval.isValid() && fwdRootIndex <= fwdInterval.upper; fwdRootIndex++)
	{	
		// extend the fwdIndex via LF mapping
		int64_t fwdIndex = fwdRootIndex;
		
		std::string currStr = initKmer;
		currStr.reserve(initKmer.length()+m_params.PBSearchDepth);
		
		for(size_t currentLength = initKmer.length(); currentLength < initKmer.length()+m_params.PBSearchDepth; currentLength++)
		{
			char b = m_params.PBindices.pRBWT->getChar(fwdIndex);
			if(b == '$') break;
			
			currStr.append(1,b);
						
			// LF mapping
            fwdIndex = m_params.PBindices.pRBWT->getPC(b) + m_params.PBindices.pRBWT->getOcc(b, fwdIndex - 1);

		}
		
		// search for solid kmers and group consecutive solids kmers into one seed
		// reduce kmer size if no seeds can be found within maxSeedInterval
		for(int i = initKmer.length() ; i+dynamicKmerSize < currStr.length() ; i++)
		{
			string kmer = currStr.substr(i, dynamicKmerSize);
			size_t fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices);
			size_t rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.PBindices);
			size_t kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
			
			// finding the seed
			if(kmerFreqs >= dynamicKmerThreshold)
			{
				std::cout << i << ":::\t" << kmer << "\t" << kmerFreqs << "\t" << seedVec.back().isRepeat << "\n";

				size_t seedStartPos = i;
				size_t maxKmerFreq = kmerFreqs;
				
				// group consecutive solid kmers into one seed if possible
				for(i++ ; i+dynamicKmerSize < currStr.length() ; i++)
				{
					kmer = currStr.substr(i, dynamicKmerSize);
					fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices);
					rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.PBindices);
					kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
					maxKmerFreq = std::max(maxKmerFreq,kmerFreqs);

					  std::cout << i << ":::\t" << kmer << "\t" << kmerFreqs << "\n";

					if(kmerFreqs < dynamicKmerThreshold)
						break;
				}
				
				// require sufficient seed length in repeats
				// if(i-seedStartPos <= 2 && dynamicKmerSize <= 21){
					// // std::cout << readSeq.substr(seedStartPos, i+dynamicKmerSize-2-seedStartPos+1) << "\n";
					// continue;
				// }

				size_t seedEndPos = i+dynamicKmerSize-2;

				// super repeat seeds with frequency > 2000 are troublesome, often lead to -3 but no good solution so far, mark first
				bool isRepeat = maxKmerFreq >= m_params.PBcoverage/3?true:false;
				if(isRepeat) 
				{
					// stay away from super repeats
					if(maxKmerFreq >= m_params.PBcoverage*4)
						i = seedEndPos+1;
					
					continue;
				}
				
				SeedFeature newSeed(seedStartPos+seedVec.back().seedStartPos, currStr.substr(seedStartPos, seedEndPos-seedStartPos+1), isRepeat, dynamicKmerSize, m_params.PBcoverage/3);
				// newSeed.estimateBestKmerSize(m_params.PBindices.pBWT);
				
				// super repeat are often in complex repeat regions where low-frequency seeds are errors.
				if(!seedVec.empty())
				{
					if( BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr.substr(0, dynamicKmerSize), m_params.indices) < 10
						/*|| !validateSeed(seedVec.back(), newSeed, maxKmerFreq)*/)
					{
						// std::cout << "#" << seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";
						continue;
					}
				}

				// skip low-complexity sequencing errors of PacBio
				// bool isShortAndHighFreq = i-seedStartPos <= 2 && maxKmerFreq > 80;
				if(!isLowComplexity(newSeed.seedStr, 0.9))
				{
					// debug
					std::cout << ">>>" << newSeed.seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize << "\t" <<  BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr.substr(0, dynamicKmerSize), m_params.indices) << "\t" << "\n" << newSeed.seedStr << "\n";
					std::cout << ">" << fwdRootIndex-fwdInterval.lower <<"\n" << currStr << "\n";

					newSeed.isPBSeed = true;
					seedVec.push_back(newSeed);
					seedEndPosVec.push_back(seedVec.back().seedStartPos+seedEndPos );
					return true;
				}
			}
		}
	}
	
	// extend each SA index and collect kmers of smallKmerSize along the extension
	for(int64_t rvcRootIndex = rvcInterval.lower; rvcInterval.isValid() && rvcRootIndex <= rvcInterval.upper; rvcRootIndex++)
	{	
		// extend the fwdIndex via LF mapping
		int64_t rvcIndex = rvcRootIndex;
		
		std::string currStr = reverseComplement(initKmer);
		currStr.reserve(initKmer.length()+m_params.PBSearchDepth);
		
		for(size_t currentLength = initKmer.length(); currentLength < initKmer.length()+m_params.PBSearchDepth; currentLength++)
		{
			char b = m_params.PBindices.pBWT->getChar(rvcIndex);
			if(b == '$') break;

			currStr = b + currStr;	// in reverse complement, currStr is before b
			
			// LF mapping
            rvcIndex = m_params.PBindices.pBWT->getPC(b) + m_params.PBindices.pBWT->getOcc(b, rvcIndex - 1);
	
		}
		currStr = reverseComplement(currStr);
		
		// search for solid kmers and group consecutive solids kmers into one seed
		// reduce kmer size if no seeds can be found within maxSeedInterval
		for(int i = initKmer.length() ; i+dynamicKmerSize < currStr.length() ; i++)
		{
			string kmer = currStr.substr(i, dynamicKmerSize);
			size_t fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices);
			size_t rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.PBindices);
			size_t kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
			
			// finding the seed
			if(kmerFreqs >= dynamicKmerThreshold)
			{
				std::cout << i << "::::\t" << kmer << "\t" << kmerFreqs << "\t" << seedVec.back().isRepeat << "\n";

				size_t seedStartPos = i;
				size_t maxKmerFreq = kmerFreqs;
				
				// group consecutive solid kmers into one seed if possible
				for(i++ ; i+dynamicKmerSize < currStr.length() ; i++)
				{
					kmer = currStr.substr(i, dynamicKmerSize);
					fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices);
					rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.PBindices);
					kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
					maxKmerFreq = std::max(maxKmerFreq,kmerFreqs);

					  std::cout << i << "::::\t" << kmer << "\t" << kmerFreqs << "\n";

					if(kmerFreqs < dynamicKmerThreshold)
						break;
				}
				
				// require sufficient seed length in repeats
				// if(i-seedStartPos <= 2 && dynamicKmerSize <= 21){
					// // std::cout << readSeq.substr(seedStartPos, i+dynamicKmerSize-2-seedStartPos+1) << "\n";
					// continue;
				// }

				size_t seedEndPos = i+dynamicKmerSize-2;

				// super repeat seeds with frequency > 2000 are troublesome, often lead to -3 but no good solution so far, mark first
				bool isRepeat = maxKmerFreq >= m_params.PBcoverage/3?true:false;
				if(isRepeat) 
				{
					// stay away from super repeats
					if(maxKmerFreq >= m_params.PBcoverage*4)
						i = seedEndPos+1;
					
					continue;
				}
				
				SeedFeature newSeed(seedStartPos+seedVec.back().seedStartPos, currStr.substr(seedStartPos, seedEndPos-seedStartPos+1), isRepeat, dynamicKmerSize, m_params.PBcoverage/3);
				// newSeed.estimateBestKmerSize(m_params.PBindices.pBWT);
				
				// super repeat are often in complex repeat regions where low-frequency seeds are errors.
				if(!seedVec.empty())
				{
					if( BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr.substr(0, dynamicKmerSize), m_params.indices) < 10
						/*||!validateSeed(seedVec.back(), newSeed, maxKmerFreq)*/)
					{
						// std::cout << "#" << seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";
						continue;
					}
				}

				// skip low-complexity sequencing errors of PacBio
				// bool isShortAndHighFreq = i-seedStartPos <= 2 && maxKmerFreq > 80;
				if(!isLowComplexity(newSeed.seedStr, 0.9))
				{
					// debug
					std::cout << ">>>>" << newSeed.seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize << "\t" << BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr.substr(0, dynamicKmerSize), m_params.indices) <<  "\n" << newSeed.seedStr << "\n";
					std::cout << ">" << rvcRootIndex-rvcInterval.lower <<"\n" << currStr << "\n";

					newSeed.isPBSeed = true;
					seedVec.push_back(newSeed);
					seedEndPosVec.push_back(seedVec.back().seedStartPos+seedEndPos );
					return true;
				}
			}
		}
	}
	
	return false;
}

int PacBioHybridCorrectionProcess::extendBetweenSeeds(SeedFeature& source, SeedFeature& target, string& strBetweenSrcTarget, int dis_between_src_target, FMWalkResult* FMWResult, int debugTargetSeed)
{	
	int FMWalkReturnType = -2;
	int PrevFMWalkReturnType = 0;	
	
	// compute minOverlap from min of seedLength and maxOverlap
	int minOverlap = std::min(source.seedLength, target.seedLength);
		minOverlap = std::min(minOverlap, m_params.maxOverlap);

	int initMinOverlap = minOverlap;
	
	FMWalkParameters FMWParams;
	FMWParams.indices = m_params.indices;
	FMWParams.maxOverlap = m_params.maxOverlap;
	FMWParams.SAThreshold = m_params.FMWKmerThreshold;
	FMWParams.disBetweenSrcTarget = dis_between_src_target;
	FMWParams.maxLeaves = m_params.maxLeaves;
	FMWParams.coverage = m_params.coverage;
	
	// debug
	// if(dis_between_src_target == 389){
		// FMWParams.debugMode = true;
		// std::cout << "\nfmwalk id: " << debugTargetSeed << ", dis_between_src_target length: " << dis_between_src_target << "\t"<< minOverlap << ".----\n";
	// }

	bool isSequencingGap = false;
	bool isSeedfromPB = source.isPBSeed || target.isPBSeed;
	
	// Correction by FM-index extension from source to target with iterative minOverlap reduction
	while( (FMWalkReturnType == -1 || FMWalkReturnType == -2) && 
			(minOverlap >= m_params.minKmerLength) && !isSeedfromPB)
	{
		FMWParams.sourceSeed = source.seedStr;
		FMWParams.targetSeed = target.seedStr;
		FMWParams.strBetweenSrcTarget = strBetweenSrcTarget;
		FMWParams.minOverlap = minOverlap;
		SAIntervalPBHybridCTree SAITree(FMWParams);
		FMWalkReturnType = SAITree.mergeTwoSeeds(*FMWResult);
		
		// if(dis_between_src_target == 389)
			// std::cout << FMWalkReturnType << ":\t" << minOverlap <<"\n";

		// Correction by FM-index extension from target to source
		if(FMWalkReturnType > 0)
		{
			FMWalkResult FMWResult2;
			FMWParams.sourceSeed = reverseComplement(target.seedStr);
			FMWParams.targetSeed = reverseComplement(source.seedStr);
			FMWParams.strBetweenSrcTarget = reverseComplement(strBetweenSrcTarget);
			SAIntervalPBHybridCTree SAITree2(FMWParams);
			FMWalkReturnType = SAITree2.mergeTwoSeeds(FMWResult2);

			// if(dis_between_src_target==389)
				std::cout << FMWalkReturnType << ":\t" << (*FMWResult).mergedSeq.length() << "\t" << FMWResult2.mergedSeq.length() << "\n";

			if((*FMWResult).mergedSeq.length() == FMWResult2.mergedSeq.length())
			{
				// select the extended seq with higher alignment score
				if((*FMWResult).alnScore < FMWResult2.alnScore)
				{
					FMWResult2.mergedSeq = reverseComplement(FMWResult2.mergedSeq);
					(*FMWResult) = FMWResult2;
				}
				break;
			}
			// Give up the extension if 2nd extension does not match the 1st one.
			if(FMWalkReturnType > 0)
				FMWalkReturnType = -4;
		}
		
		/*** Extension Failed 1) try smaller minOverlap 2) try correction by MSA for sequencing gap ***/
		// Sequencing gaps in short reads often lead to -1 or -2
		// But over-reduced minOverlap size also lead to -2 due to error seeds
		if( (FMWalkReturnType == -2 && minOverlap >= m_params.kmerLength) || 
			(FMWalkReturnType == -1 && minOverlap == initMinOverlap) )
			isSequencingGap = true;
		
		// The FMWalkReturnType may switch from -1 to -3 due to over-reduced minOverlap
		// We have to skip further reduction and reset the FMWalkReturnType
		if(FMWalkReturnType == -3 && PrevFMWalkReturnType == -1)
		{
			// the current -3 state is incorrect, reset to prev status
			FMWalkReturnType = PrevFMWalkReturnType;
			break;
		}
		
		PrevFMWalkReturnType = FMWalkReturnType;
		minOverlap--;	
		
		// FMWalkReturnType -2 leads to misassembly in C elegans
		// FMWalkReturnType < 0 generates bette r assembly in E coli
		if(source.isRepeat && minOverlap < m_params.kmerLength-1) break;
	}

	std::cout << FMWalkReturnType << "\t" << dis_between_src_target <<"\t"<< target.seedStr << "\t" 
			<< source.endKmerFreq << target.endKmerFreq << source.isPBSeed << target.isPBSeed << "\n";
	
	// try correction by MSA using FM-index of low quality long reads for sequencing gaps
	if( (FMWalkReturnType == -2 || FMWalkReturnType == -1 || FMWalkReturnType == -3) /*&& !source.isRepeat && !target.isRepeat */
		/*&& (isSequencingGap || isSeedfromPB)*/ )
	{
		// mimic the overlap correction process
		// const std::string query = source.seedStr.substr(source.seedLength - m_params.PBKmerLength)+strBetweenSrcTarget.substr(10, dis_between_src_target)+target.seedStr;
		const std::string query = source.seedStr.substr(source.seedLength - source.endBestKmerSize)+strBetweenSrcTarget.substr(10, dis_between_src_target)+target.seedStr;
		size_t targetKmerLength = target.endBestKmerSize;
		size_t sourceKmerLength = source.endBestKmerSize;
		
		// std::cout << minOverlap << "\t" << query.length() << "\n" << query << "\n";
		
		// Self correction by aligning all reads having seeds with query
		MultipleAlignment maquery = LongReadOverlap::buildMultipleAlignment(query,
													sourceKmerLength,//m_params.PBKmerLength, 
													targetKmerLength,//m_params.PBKmerLength,
													query.length()/10, 
													0.75,	// alignment identity < 0.7 are often false positive repeats
													m_params.PBcoverage,
													m_params.PBindices); 

		std::cout << minOverlap << "\t" << query.length()<< "\t" << maquery.getNumRows() <<"\n";
		// skip insufficient number of overlapping reads for correction
		if(maquery.getNumRows() <= 3)
			return FMWalkReturnType;
		
		// maquery.print(120);
		std::string consensus = maquery.calculateBaseConsensus(100000, -1);
		FMWResult->mergedSeq = source.seedStr + consensus.substr(sourceKmerLength);
		// std::cout << ">" << consensus.length() <<"\n" << consensus << "\n";
		
		return 1;
		
		/* Self-correction by FM-index extenion is suitable for high-coverage PB sequencing
		
		FMWParams.lowCoverageHighErrorMode = true;
		FMWParams.minOverlap = m_params.minKmerLength;
		FMWParams.maxOverlap = m_params.kmerLength;
		FMWParams.sourceSeed = source.seedStr;
		FMWParams.targetSeed = target.seedStr;
		SAIntervalPBHybridCTree SAITree(FMWParams);

		const double maxRatio = 1.1;
		const double minRatio = 0.9;
		const int minOffSet = 30;	//PB159615_16774.fa contains large indels > 30bp
		const size_t extendKmerSize = 15;
		const size_t srcKmerSize = 17;
		
		SAIPBSelfCorrectTree SAITree(m_params.PBindices.pBWT, m_params.PBindices.pRBWT, strBetweenSrcTarget, 2);
			
		// this occurs when one end is repeat requiring larger extendKmerSize while the other requires small extendKmerSize
		// the source str should be the longest one
		// const int srcMaxLength = maxRatio*(dis_between_src_target+minOffSet) + source.seedLength + extendKmerSize;
		// size_t sourceFreq = SAITree.addHashBySingleSeed(source.seedStr, source.endBestKmerSize, extendKmerSize, srcMaxLength, m_params.isFirst);
		
		std::string srcStr = source.seedStr.substr(source.seedStr.length()-srcKmerSize);
		size_t srcMaxLength = maxRatio*(dis_between_src_target+minOffSet) + srcStr.length() + extendKmerSize;
		// size_t sourceFreq = SAITree.addHashBySingleSeed(srcStr, srcKmerSize, extendKmerSize, srcMaxLength, true);

		// srcStr = source.seedStr.substr(source.seedStr.length()-srcKmerSize*3.5, srcKmerSize);
		// SAITree.addHashBySingleSeed(srcStr, srcKmerSize, extendKmerSize, srcMaxLength, true);		
		srcStr = source.seedStr.substr(source.seedStr.length()-srcKmerSize*2, srcKmerSize);
		SAITree.addHashBySingleSeed(srcStr, srcKmerSize, extendKmerSize, srcMaxLength, true);
		srcStr = source.seedStr.substr(source.seedStr.length()-srcKmerSize*3, srcKmerSize);
		SAITree.addHashBySingleSeed(srcStr, srcKmerSize, extendKmerSize, srcMaxLength, true);
		srcStr = source.seedStr.substr(source.seedStr.length()-srcKmerSize*1.5, srcKmerSize);
		SAITree.addHashBySingleSeed(srcStr, srcKmerSize, extendKmerSize, srcMaxLength, true);		
		
		srcStr = source.seedStr.substr(source.seedStr.length()-srcKmerSize);
		
		// Collect local kmer frequency from target upto targetMaxLength
		std::string rvcTargetStr = reverseComplement(target.seedStr);
		const int targetMaxLength = maxRatio*(dis_between_src_target+minOffSet) + rvcTargetStr.length() + srcKmerSize;
		size_t expectedLength = dis_between_src_target + rvcTargetStr.length();
		assert(rvcTargetStr.length()>=extendKmerSize);
		size_t targetFreq = SAITree.addHashBySingleSeed(rvcTargetStr, srcKmerSize, extendKmerSize, targetMaxLength, true, expectedLength);

		int srcMinLength = minRatio*(dis_between_src_target-minOffSet) + srcStr.length() + extendKmerSize;
		if(srcMinLength < 0) srcMinLength = 0;
		expectedLength = srcStr.length() + dis_between_src_target + target.seedLength;
		
		std::string pbseq;
		FMWalkReturnType = SAITree.mergeTwoSeedsUsingHash(srcStr, target.seedStr, pbseq, extendKmerSize, m_params.maxLeaves,
														  srcMinLength, srcMaxLength, expectedLength);	

		// debug
		// std::cout << dis_between_src_target << "\t" << FMWalkReturnType << "\t"<< source.seedStartPos << "\t" << target.seedStr << "\n";
		if(!pbseq.empty())
			*mergedseq = source.seedStr+pbseq.substr(srcKmerSize);
		*/
	}

	return FMWalkReturnType;
}


// boundary of repeat seeds are less reliable
// trim the base with lower frequency in comparison with others
void PacBioHybridCorrectionProcess::trimRepeatSeed(const string& readSeq, size_t coverage, size_t dynamicKmerSize, size_t& seedStartPos, size_t& seedEndPos, const BWTIndexSet indices)
{
	// initially set to max unisnged int value
	size_t newSeedStartPos = (size_t)-1;
	size_t newSeedEndPos = (size_t)-1;
	
	size_t kmerSize = dynamicKmerSize;
	
	const int minRepeatFreq = coverage;
	double minFreqDiff = 0.5;
	
	std::string kmer = readSeq.substr(seedStartPos, kmerSize);
	int initKmerFreq = BWTAlgorithms::countSequenceOccurrences(kmer, indices);
	
	int prevKmerFreq = initKmerFreq;
	size_t startKmerFreq=0, endKmerFreq=0;


	// first kmer is a repeat
	if(initKmerFreq > minRepeatFreq)
	{
		newSeedStartPos = seedStartPos;
		startKmerFreq = initKmerFreq;
	}
	
	
	// identify breakpoints of large freq difference between two kmers	
	for(size_t i=seedStartPos+1 ; i+kmerSize-1 <= seedEndPos; i++)
	{
		kmer = readSeq.substr(i, kmerSize);
		int currKmerFreq = BWTAlgorithms::countSequenceOccurrences(kmer, indices);

		// if(seedStartPos == 3829)
			// std::cout << i << ": " << kmer << "\t" << currKmerFreq << "\t" << newSeedStartPos <<"\t" << newSeedEndPos << "\n";

		// error kmers within repeats often lead to large freq diff
		bool isLargeFreqDiff = (currKmerFreq - prevKmerFreq)/(double)currKmerFreq > minFreqDiff;
		
		// PB36993_4517.fa, TTATGTAAGGAGTATTTGAT
		// some error kmers are with moderate frequency and no freq diff can be observed
		// pick up the first repeat kmer as starting point
		bool isRepeatKmer = (newSeedStartPos == (size_t)-1) && (currKmerFreq >= (int)minRepeatFreq);
		if(isLargeFreqDiff || isRepeatKmer)
		{
			// capture the highest repeat start pos
			bool isBetterRepeatKmer = (startKmerFreq!=0 && currKmerFreq > (int)startKmerFreq);
			if(newSeedStartPos == (size_t)-1 || isBetterRepeatKmer)
			{
				newSeedStartPos = i;
				startKmerFreq = currKmerFreq;
			}
		}
			
		// repeat end is reached
		// PB36993_4517.fa, AGGCTTGTCTGTAATCGGG
		isLargeFreqDiff = (prevKmerFreq - currKmerFreq)/(double)prevKmerFreq > minFreqDiff;
		if(isLargeFreqDiff /*|| currKmerFreq < minFreqDiff*/)
		{
			// do not enter unless start pos was found
			// if(newSeedStartPos != (size_t)-1)
			// {
				newSeedEndPos = i + kmerSize -2;
				endKmerFreq = prevKmerFreq;
				break;
			// }
		}
			
		prevKmerFreq = currKmerFreq;
	}
	
	if(newSeedStartPos == (size_t)-1)
	{
		newSeedStartPos = seedStartPos;
		startKmerFreq = initKmerFreq;
	}
		
	if(newSeedEndPos == (size_t)-1)
	{
		newSeedEndPos = seedEndPos;
		endKmerFreq = prevKmerFreq;
	}

	seedStartPos = newSeedStartPos;
	seedEndPos = newSeedEndPos;
	return;
}

// Validate seed accuracy via FM-index extension from target seed;
bool PacBioHybridCorrectionProcess::validateSeed(SeedFeature& source, SeedFeature& target, size_t /*maxKmerFreq*/)
{
	size_t sourceKmerLength = source.isRepeat?source.seedLength:source.endBestKmerSize;	
	size_t targetKmerLength = target.isRepeat?target.seedLength:target.startBestKmerSize;
	
	const size_t extLen = 7;
	AlphaCountVector<int> srcExtCount(extLen), tarExtCount(extLen);
	size_t lenDiff1;
	
	// extend from source
	std::string initKmer = source.seedStr.substr(source.seedLength - sourceKmerLength);
	std::string endingKmer = target.seedStr.substr(target.seedLength - targetKmerLength);
	size_t disBetweenSrcTarget = target.seedStartPos - source.seedEndPos + 1;
	size_t isFirstOK = validateExtension(initKmer, endingKmer, disBetweenSrcTarget, srcExtCount, tarExtCount, lenDiff1);

	// extend from target
	AlphaCountVector<int> srcExtCountComp(extLen), tarExtCountComp(extLen);
	size_t lenDiff2;
	// initKmer = reverseComplement(target.seedStr.substr(target.seedLength - targetKmerLength));
	initKmer = reverseComplement(target.seedStr.substr(0, targetKmerLength));
	endingKmer = reverseComplement(source.seedStr.substr(source.seedLength - sourceKmerLength));
	size_t isSecondOK = validateExtension(initKmer, endingKmer, disBetweenSrcTarget, tarExtCountComp, srcExtCountComp, lenDiff2);

	bool isExtReliable = srcExtCount.isExtReliable(3) && tarExtCount.isExtReliable(3);
	if(source.isRepeat && target.isRepeat && !isExtReliable) return false;
	
	srcExtCountComp.reverseComplement();
	tarExtCountComp.reverseComplement();
	
	// if(source.isRepeat && target.isRepeat)
		// tarExtCount += tarExtCountComp;
	
	// srcExtCount += srcExtCountComp;
	// tarExtCount += tarExtCountComp;
	
	bool isTotalFreqOK = isFirstOK >= 2 && isSecondOK >= 2;	// 2 will be from original raw read
	bool isLenDiffOK = (lenDiff1 <= 90 && lenDiff2 <= 90) ;
	bool isRepeatSafe = (source.isRepeat || target.isRepeat) && (isFirstOK >= 3 || isSecondOK >=3 );
	bool bothNotRepeat = !source.isRepeat && !target.isRepeat;
	                                                                                                
	bool isFreqLenOK = isTotalFreqOK && isLenDiffOK /*&& (isRepeatSafe || bothNotRepeat)*/;
	
	// std::cout << isTotalFreqOK << isLenDiffOK << isRepeatSafe << bothNotRepeat << target.startBestKmerSize<< "\n";
	// std::cout << srcExtCount << srcExtCount.at(0).getMaxBase() << "\n" 
			// << tarExtCount << tarExtCount.at(0).getMaxBase() << "\n" 
			// << srcExtCountComp << "\n" << tarExtCountComp << "\n";
	// std::cout << tarExtCountComp.fwdConsensus(2) << "::" << tarExtCount.fwdConsensus(2) <<"\n";

	// if(target.isRepeat && (tarExtCount.at(0).getMaxCount() >= 2 || tarExtCountComp.at(0).getMaxCount() >= 2) && isFreqLenOK)
	// {
		// std::string tmp = tarExtCount.fwdConsensus(2);		
		// target.prepend(tmp);
		// target.startBestKmerSize+=tmp.length();
	// }
	
	return isFreqLenOK;
		
}

// Validate seed accuracy via FM-index extension from target seed;
size_t PacBioHybridCorrectionProcess::validateExtension(string& initKmer, string& endingKmer, size_t disBetweenSrcTarget, AlphaCountVector<int>& srcExtCount, AlphaCountVector<int>& tarLeftExtCount, size_t& lenDiff)
{
	// PacBio errors create repeat-like seeds with large interval
	// limit the upper bound of interval for speedup
	const int64_t maxIntervalSize = 256;
	const size_t rawSeqLength = disBetweenSrcTarget+initKmer.length()+endingKmer.length();
	size_t maxLength = disBetweenSrcTarget*1.1 + initKmer.length()+endingKmer.length() + 30;
	size_t minLength = disBetweenSrcTarget*0.9 + initKmer.length()+endingKmer.length() - 30;
	const size_t freqCutoff = 5;
	
	// if(maxLength-disBetweenSrcTarget-initKmer.length()-endingKmer.length()>90) maxLength=disBetweenSrcTarget+initKmer.length()+endingKmer.length()+90;
	// if(disBetweenSrcTarget+initKmer.length()+endingKmer.length()-minLength>90) minLength=disBetweenSrcTarget+initKmer.length()+endingKmer.length()-90;
	
	// LF-mapping of each fwd index using largeKmerSize
	// assert(seedStr.length() >= largeKmerSize);
	BWTInterval fwdInterval=BWTAlgorithms::findInterval(m_params.PBindices.pRBWT, reverse(initKmer));
	BWTInterval rvcInterval=BWTAlgorithms::findInterval(m_params.PBindices.pBWT, reverseComplement(initKmer));
    
	BWTInterval fwdEndingInterval=BWTAlgorithms::findInterval(m_params.PBindices.pRBWT, reverse(endingKmer));
	BWTInterval rvcEndingInterval=BWTAlgorithms::findInterval(m_params.PBindices.pBWT, reverseComplement(endingKmer));
	
	size_t kmerFreq = 0;
	kmerFreq += fwdInterval.isValid()?fwdInterval.size():0;
	kmerFreq += fwdInterval.isValid()?rvcInterval.size():0;

	// std::cout << initKmer << "\t" << m_params.PBKmerLength << "\t" << reverseComplement(initKmer) << "\t" << fwdInterval.size() << "\t" << rvcInterval.size() << "\t" << kmerFreq << "\n";
	
	size_t count = 0;
	size_t maxCurrLen=0, minCurrLen = 1000000;
	// extend each SA index and collect kmers of smallKmerSize along the extension
	for(int64_t fwdRootIndex = fwdInterval.lower; 
		fwdInterval.isValid() && fwdRootIndex <= fwdInterval.upper &&  fwdRootIndex - fwdInterval.lower < maxIntervalSize; 
		fwdRootIndex++)
	{	
		// extend the fwdIndex via LF mapping
		int64_t fwdIndex = fwdRootIndex;
		
		std::string currStr = initKmer;
		currStr.reserve(maxLength);
		
		for(size_t currentLength = initKmer.length(); currentLength <= maxLength; currentLength++)
		{
			char b = m_params.PBindices.pRBWT->getChar(fwdIndex);
			if(b == '$') break;
			
			currStr.append(1,b);
						
			// LF mapping
            fwdIndex = m_params.PBindices.pRBWT->getPC(b) + m_params.PBindices.pRBWT->getOcc(b, fwdIndex - 1);

			if(fwdIndex >= fwdEndingInterval.lower && fwdIndex <= fwdEndingInterval.upper && currentLength >= minLength)
			{
				if(currentLength < minCurrLen) minCurrLen = currentLength;
				if(currentLength > maxCurrLen) maxCurrLen = currentLength;

				count++;
				// srcExtCount.at(0).increment(currStr.at(initKmer.length()));
				// tarLeftExtCount.at(0).increment(currStr.at(currStr.length()-endingKmer.length()-1));
				srcExtCount.incrementStr(currStr.substr(initKmer.length(), srcExtCount.getLength()+8));
				std::string tarStr = currStr.substr(currStr.length()-endingKmer.length()-tarLeftExtCount.getLength(), tarLeftExtCount.getLength());
				tarLeftExtCount.incrementStr( tarStr );
				
				// std::cout << "Src: "<< currStr.substr(0,initKmer.length()) << "\t"
						// << "tar: " << currStr.substr(currStr.length()-endingKmer.length()) << "\t"
						// << currentLength << "\t" << disBetweenSrcTarget+ initKmer.length()+endingKmer.length()  << "\n";
						
				// if(rawSeqLength == 8192) std::cout << ">\n" << currStr <<"\n";
			}
			
			if(count >= freqCutoff) break;
		}
		
		if(count >= freqCutoff) break;
	}

	
	// LF-mapping of each rvc index	
	for(int64_t rvcRootIndex=rvcInterval.lower; 
		rvcRootIndex <= rvcInterval.upper && rvcInterval.isValid() && rvcRootIndex - rvcInterval.lower < maxIntervalSize; 
		rvcRootIndex++)
	{		
		int64_t rvcIndex = rvcRootIndex;
		// extract the string of fwdIndex via LF mapping
		std::string currStr = reverseComplement(initKmer);
		currStr.reserve(maxLength);
			
		for(size_t currentLength = initKmer.length(); currentLength <= maxLength; currentLength++)
		{
			char b = m_params.PBindices.pBWT->getChar(rvcIndex);
			if(b == '$') break;

			currStr = b + currStr;	// in reverse complement, currStr is before b
			
			// LF mapping
            rvcIndex = m_params.PBindices.pBWT->getPC(b) + m_params.PBindices.pBWT->getOcc(b, rvcIndex - 1);
			
			if(rvcIndex >= rvcEndingInterval.lower && rvcIndex <= rvcEndingInterval.upper && currentLength >= minLength)
			{				
				if(currentLength < minCurrLen) minCurrLen = currentLength;
				if(currentLength > maxCurrLen) maxCurrLen = currentLength;

				count++;
				currStr = reverseComplement(currStr);
				// srcExtCount.at(0).increment(currStr.at(initKmer.length()));
				// tarLeftExtCount.at(0).increment(currStr.at(currStr.length()-endingKmer.length()-1));
				srcExtCount.incrementStr(currStr.substr(initKmer.length(), srcExtCount.getLength()));
				std::string tarStr = currStr.substr(currStr.length()-endingKmer.length()-tarLeftExtCount.getLength(), tarLeftExtCount.getLength());
				tarLeftExtCount.incrementStr( tarStr );
				
				// std::cout << "Src: "<< currStr.substr(0,initKmer.length()) << "\t"
						// << "tar: " << currStr.substr(currStr.length()-endingKmer.length()) << "\t"
						// << currentLength << "\t" << disBetweenSrcTarget+ initKmer.length()+endingKmer.length()  << "\n";
			}
			
			if(count >= freqCutoff) break;
		}
		
		if(count >= freqCutoff) break;
	}
	
	// if(count >= freqCutoff && maxCurrLen - minCurrLen >= 90) count = 0; 
	lenDiff = maxCurrLen - minCurrLen;
	// std::cout << "Seed validate: " << fwdInterval.size() <<"\t" << rvcInterval.size() << "\t" << count << "\t" << maxCurrLen - minCurrLen << "\n";
	return count;
}

//
//
PacBioHybridCorrectionPostProcess::PacBioHybridCorrectionPostProcess(std::ostream* pCorrectedWriter, std::ostream* pDiscardWriter, const PacBioHybridCorrectionParameters params):
	m_pCorrectedWriter(pCorrectedWriter),
	m_pDiscardWriter(pDiscardWriter),
	m_params(params),
	m_totalReadsLen(0),
	m_correctedLen(0),
	m_totalSeedNum(0),
	m_totalWalkNum(0),
	m_correctedNum(0),
	m_highErrorNum(0),
	m_exceedDepthNum(0),
	m_exceedLeaveNum(0),
	m_seedDis(0)
{
}

//
PacBioHybridCorrectionPostProcess::~PacBioHybridCorrectionPostProcess()
{	
	if(m_totalWalkNum>0 && m_totalReadsLen>0)
	{
		std::cout << std::endl;
		std::cout << "totalReadsLen: " << m_totalReadsLen << ", ";
		std::cout << "correctedLen: " << m_correctedLen << ", ratio: " 
			<< (float)(m_correctedLen)/m_totalReadsLen << "%." << std::endl;
		std::cout << "totalSeedNum: " << m_totalSeedNum << "." << std::endl;
		std::cout << "totalWalkNum: " << m_totalWalkNum << ", ";
		std::cout << "correctedNum: " << m_correctedNum << ", ratio: " 
			<< (float)(m_correctedNum*100)/m_totalWalkNum << "%." << std::endl;
		std::cout << "seedDis: " << (float)(m_seedDis)/m_totalWalkNum << "." << std::endl;
		//std::cout << "highErrorNum: " << m_highErrorNum << ", ratio: " << (float)(m_highErrorNum*100)/m_totalWalkNum << "%." << std::endl;
		//std::cout << "exceedDepthNum: " << m_exceedDepthNum << ", ratio: " << (float)(m_exceedDepthNum*100)/m_totalWalkNum << "%." << std::endl;
		//std::cout << "exceedLeaveNum: " << m_exceedLeaveNum << ", ratio: " << (float)(m_exceedLeaveNum*100)/m_totalWalkNum << "%." << std::endl;
	}
}


// Writting results for kmerize and validate
void PacBioHybridCorrectionPostProcess::process(const SequenceWorkItem& item, const PacBioHybridCorrectionResult& result)
{
	if(result.merge)
	{
		m_totalReadsLen += result.totalReadsLen;
		m_correctedLen += result.correctedLen;
		m_totalSeedNum += result.totalSeedNum;
		m_totalWalkNum += result.totalWalkNum;
		m_correctedNum += result.correctedNum;
		m_highErrorNum += result.highErrorNum;
		m_exceedDepthNum += result.exceedDepthNum;
		m_exceedLeaveNum += result.exceedLeaveNum;
		m_seedDis += result.seedDis;
		
		for(size_t i = 0 ; i < result.correctedPacbioStrs.size() ; i++)
		{
			SeqItem mergeRecord;
			std::stringstream ss;
			ss << item.read.id << "_" << i << "_" << result.correctedPacbioStrs[i].toString().length();
			mergeRecord.id = ss.str();
			mergeRecord.seq = result.correctedPacbioStrs[i];
			mergeRecord.write(*m_pCorrectedWriter);
		}
	}
	else
	{
		// write into discard.fa
		SeqItem mergeRecord;
		mergeRecord.id = item.read.id;
		mergeRecord.seq = item.read.seq;
		mergeRecord.write(*m_pDiscardWriter);
	}
}



// PacBio Hybrid Correction Seeding By Dynamic Kmer, v20160217 by Ya.
// find seeds by dynamic kmers, which is suitable for the PacBio hybrid error correction,
// where repeat regions require large kmers and error-prone regions require small kmers.
std::vector<SeedFeature> PacBioHybridCorrectionProcess::seedingByDynamicKmer(const string& readSeq)
{
	std::vector<SeedFeature> seedVec;
	std::vector<int> seedEndPosVec;
	size_t maxKmerSize = m_params.kmerLength;
	size_t minKmerSize = m_params.minKmerLength;
	size_t kmerThreshold = m_params.seedKmerThreshold;
	int prevPBSeedEndPos = 0;

	// prevention of short reads
	if(readSeq.length() < maxKmerSize)
		return seedVec;
	
	// computing maximum interval of variously consecutive matches length (dk figure)
	std::vector<int> maxSeedInterval;
	for(size_t i = 0 ; i <= maxKmerSize ; i++)
		maxSeedInterval.push_back(2*3.8649*pow(2.7183,0.1239*i));
	
	// set dynamic kmer as largest kmer initially, 
	// which will reduce size when no seeds can be found within a maximum interval.
	size_t dynamicKmerSize = maxKmerSize;
	size_t dynamicKmerThreshold = kmerThreshold;
		
	// search for solid kmers and group consecutive solids kmers into one seed
	// reduce kmer size if no seeds can be found within maxSeedInterval
	for(size_t i = 0 ; i+dynamicKmerSize <= readSeq.length() ; i++)
	{
		string kmer = readSeq.substr(i, dynamicKmerSize);
		size_t fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.indices);
		size_t rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.indices);
		size_t kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
		
		// std::cout << i << ":\t" << kmer << "\t" << kmerFreqs << "\n";
		// std::cout << i << "::\t" << kmer << "\t" << BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices) << "\n";

		// finding the seed
		if(kmerFreqs >= dynamicKmerThreshold && kmerFreqs < m_params.coverage*2/3)
		{
			size_t seedStartPos = i;
			size_t maxKmerFreq = kmerFreqs;
			
			// group consecutive solid kmers into one seed if possible
			for(i++ ; i+dynamicKmerSize <= readSeq.length() ; i++)
			{
				kmer = readSeq.substr(i, dynamicKmerSize);
				fwdKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.indices);
				rvcKmerFreqs = BWTAlgorithms::countSequenceOccurrencesSingleStrand(reverseComplement(kmer), m_params.indices);
				kmerFreqs = fwdKmerFreqs+rvcKmerFreqs;
				maxKmerFreq = std::max(maxKmerFreq,kmerFreqs);

				// std::cout << i << ":\t" << kmer << "\t" << kmerFreqs << "\n";
				// std::cout << i << "::\t" << kmer << "\t" << BWTAlgorithms::countSequenceOccurrencesSingleStrand(kmer, m_params.PBindices) << "\n";

				if(kmerFreqs < dynamicKmerThreshold || kmerFreqs >= m_params.coverage*2/3)
					break;
			}
			
			size_t seedEndPos = i+dynamicKmerSize-2;

			// repeat seeds are less accurate at boundary and should be trimmed 
			if(maxKmerFreq > m_params.coverage*2/3)
			{
				continue;
				// trimRepeatSeed(readSeq, m_params.coverage, dynamicKmerSize, seedStartPos, seedEndPos, m_params.indices);
			}

			// small-sized seed has 50% chance of errors in C elegans, 
			// skip only if there is another seed nearby 30bp or dynamic kmerSize is too small
			if( (i-seedStartPos) < 3 && !seedVec.empty() /*&&
				(i-seedVec.back().seedEndPos <= 30 )
				|| dynamicKmerSize <= (size_t)m_params.kmerLength-5) */)
				continue;

			// super repeat seeds with frequency > 2000 are troublesome, often lead to -3 but no good solution so far, mark first
			bool isSuperRepeat = maxKmerFreq > m_params.coverage*2/3?true:false;				
			SeedFeature newSeed(seedStartPos, readSeq.substr(seedStartPos, seedEndPos-seedStartPos+1), isSuperRepeat, dynamicKmerSize, m_params.PBcoverage/2);
			newSeed.estimateBestKmerSize(m_params.PBindices.pBWT);

			// size_t PBkmerFreq = BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr.substr(0, dynamicKmerSize), m_params.PBindices);
			size_t PBkmerFreq = BWTAlgorithms::countSequenceOccurrences(newSeed.seedStr, m_params.PBindices);
			if( PBkmerFreq < 3 || PBkmerFreq > m_params.PBcoverage/2) 
			{
				// std::cout << "#" << seedStartPos << "." << PBkmerFreq << ":" << maxKmerFreq << "\t" << dynamicKmerSize  <<  "\n" << newSeed.seedStr << "\n";
				continue;
			}


			// super repeat are often in complex repeat regions where low-frequency seeds are errors.
			if(!seedVec.empty() /*&& (seedVec.back().isRepeat || newSeed.isRepeat)*/)
			{
				if(!validateSeed(seedVec.back(), newSeed, maxKmerFreq))
				{
					// std::cout << "X" << seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize << "\t" << dynamicKmerThreshold <<  "\n" << newSeed.seedStr << "\n";

					// seedEndPosVec.push_back(seedEndPos);
					// i = seedEndPos;
					// dynamicKmerSize = maxKmerSize;
					// dynamicKmerThreshold = kmerThreshold;
					continue;
				}
			}

			// skip low-complexity sequencing errors of PacBio
			// bool isShortAndHighFreq = i-seedStartPos <= 2 && maxKmerFreq > 80;
			if(!isLowComplexity(newSeed.seedStr, 0.9))
				seedVec.push_back(newSeed);
			
			seedEndPosVec.push_back(seedEndPos);
			
			// debug
			std::cout << ">" << seedStartPos << "." << newSeed.seedLength << ":" << maxKmerFreq << "\t" << dynamicKmerSize << "\t" << dynamicKmerThreshold <<  "\n" << newSeed.seedStr << "\n";
			
			// jump to the index after new seed
			i = seedEndPos;
			dynamicKmerSize = maxKmerSize;
			dynamicKmerThreshold = kmerThreshold;
			prevPBSeedEndPos = seedEndPos;
		}
		
		// reduce kmer size if no seeds can be found within a maximum interval
		int prevSeedEndPos = seedEndPosVec.empty() ? 0 : seedEndPosVec.back()+1;
		int distToPrevSeed = i + 1 - prevSeedEndPos;
		if(distToPrevSeed >= (int)maxSeedInterval.at(dynamicKmerSize))
		{
			// reducing the kmer size
			if(dynamicKmerSize > minKmerSize)
			{
				i = prevSeedEndPos;
				dynamicKmerSize -= 2;
				dynamicKmerThreshold +=2;
			}
			else
			{
				// collect seeds from PacBio reads if distToPrevSeed is too long due to sequencing gaps
				// prevSeedEndPos = seedVec.empty() ? 0 : seedVec.back().seedEndPos+1;
				distToPrevSeed = i + 1 - prevPBSeedEndPos;
				
				/* In large sequencing gaps (>7kb), no seeds can be found in Illumina index
					If no seed is found within PBSearchDepth, 
					seeds from PB index will be serached instead*/
				if(distToPrevSeed >= m_params.PBSearchDepth)
				{	
					if(seedingByPacBio(readSeq, seedVec, seedEndPosVec, prevPBSeedEndPos) 
						/*|| seedingByExtension(seedVec, seedEndPosVec)*/ )
						prevPBSeedEndPos = seedEndPosVec.back();
					else
						prevPBSeedEndPos = i;
				}
				// no seeds can be found even using minKmerSize, 
				// so we reset start position of searching to give up the maximum interval of minKmerSize.
				seedEndPosVec.push_back(i);
				dynamicKmerSize = maxKmerSize;
				dynamicKmerThreshold = kmerThreshold;

			}
		}
	}
	
	return seedVec;
}
